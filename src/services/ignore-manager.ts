import { App, FileSystemAdapter, Platform } from "obsidian";
import { Logger, LOG_MODULES } from "../utils/logger";

interface SystemError {
	code?: string;
}

interface ExecException extends Error {
	cmd?: string;
	killed?: boolean;
	code?: number | string;
	signal?: string;
}

interface ChildProcessLib {
	exec: (
		command: string,
		callback: (
			error: ExecException | null,
			stdout: string,
			stderr: string,
		) => void,
	) => void;
}

interface ElectronWindow {
	require(module: "child_process"): ChildProcessLib;
}

export class IgnoreManager {
	app: App;
	ignoreFile = ".stignore";

	constructor(app: App) {
		this.app = app;
	}

	async ensureDefaults() {
		// [CORREÇÃO] Obtém o nome real da pasta de configuração (ex: .obsidian)
		const configDir = this.app.vault.configDir;

		// Regras críticas que SEMPRE devem existir para o plugin funcionar bem
		const pluginRules = [
			"# --- Syncthing Controller Plugin Data ---",
			// O banco de dados do plugin é local e não deve ser sincronizado
			`**/${configDir}/plugins/syncthing-manager/sync-state.json`,
			`**/${configDir}/plugins/syncthing-manager/sync-state.sync-conflict*`,
			`**/${configDir}/plugins/syncthing-manager/~syncthing~sync-state.json.tmp`,
			// Regra genérica caso o usuário tenha movido a pasta do plugin ou use outro layout
			"**/sync-state.json",
			"**/sync-state.sync-conflict*",
		];

		const exists = await this.app.vault.adapter.exists(this.ignoreFile);

		if (!exists) {
			const defaultContent = `
# --- Generated by Syncthing Controller ---
# Ignora configurações de janela/workspace
${configDir}/workspace*

# Ignora cache de instalador
${configDir}/installer.json

${pluginRules.join("\n")}
            `.trim();

			try {
				await this.saveIgnoreFile(defaultContent);
				Logger.debug(
					LOG_MODULES.MAIN,
					"Arquivo .stignore criado com regras padrão.",
				);
			} catch (e) {
				Logger.warn(
					LOG_MODULES.MAIN,
					"Falha ao criar .stignore padrão",
					e,
				);
			}
		} else {
			// Se já existe, verificamos se as regras do plugin estão lá
			await this.ensurePluginRulesExist(pluginRules);
		}
	}

	private async ensurePluginRulesExist(rules: string[]) {
		try {
			const content = await this.readIgnoreFile();
			let newContent = content;
			let modified = false;

			// Verifica se já tem cabeçalho do plugin, se não, adiciona
			if (!newContent.includes("Syncthing Controller Plugin Data")) {
				newContent += "\n\n# --- Syncthing Controller Plugin Data ---";
			}

			for (const rule of rules) {
				if (rule.startsWith("#")) continue; // Pula comentários na verificação
				if (!newContent.includes(rule)) {
					newContent += `\n${rule}`;
					modified = true;
				}
			}

			if (modified) {
				await this.saveIgnoreFile(newContent);
				Logger.debug(
					LOG_MODULES.MAIN,
					"Arquivo .stignore atualizado com regras de exclusão do plugin.",
				);
			}
		} catch (e) {
			Logger.warn(
				LOG_MODULES.MAIN,
				"Erro ao verificar regras no .stignore existente",
				e,
			);
		}
	}

	async readIgnoreFile(): Promise<string> {
		if (await this.app.vault.adapter.exists(this.ignoreFile)) {
			return await this.app.vault.adapter.read(this.ignoreFile);
		}
		return "";
	}

	async saveIgnoreFile(content: string) {
		try {
			await this.app.vault.adapter.write(this.ignoreFile, content);
		} catch (error) {
			const sysError = error as SystemError;
			if (
				(sysError.code === "EPERM" || sysError.code === "EACCES") &&
				Platform.isWin
			) {
				await this.forceWriteWindows(content);
			} else {
				throw error;
			}
		}
	}

	private async forceWriteWindows(content: string) {
		const adapter = this.app.vault.adapter;

		if (!(adapter instanceof FileSystemAdapter)) {
			throw new Error(
				"O adaptador de arquivos não suporta acesso ao caminho completo (Mobile?).",
			);
		}

		const fullPath = adapter.getFullPath(this.ignoreFile);

		// Remove atributo oculto para permitir escrita
		await this.runCmd(`attrib -h "${fullPath}"`);

		try {
			await adapter.write(this.ignoreFile, content);
		} finally {
			// Restaura atributo oculto
			await this.runCmd(`attrib +h "${fullPath}"`).catch((err) =>
				console.error("Falha ao re-ocultar .stignore", err),
			);
		}
	}

	private runCmd(command: string): Promise<void> {
		return new Promise((resolve, reject) => {
			const win = window as unknown as ElectronWindow;
			const { exec } = win.require("child_process");

			exec(command, (error) => {
				if (error) {
					reject(error);
				} else {
					resolve();
				}
			});
		});
	}
}
